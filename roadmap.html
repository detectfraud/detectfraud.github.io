<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>–ö–∞–º—ñ–Ω—å –ª—é–±–æ–≤—ñ ‚Äî —Ä–µ–¥–∞–∫—Ç–æ—Ä</title>
<style>
  body { text-align:center; font-family:sans-serif; }
  .venwin { background: #fff; border-radius:10px; padding:10px; display:inline-block; }
  canvas { border:3px solid #bbb; border-radius:6px; box-shadow:0 6px 18px rgba(0,0,0,.1); display:block; margin:10px auto; }
  #controls{ margin-top:10px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
  #scaleSlider{ width:420px; }
  button{ padding:8px 12px; }
</style>
</head>
<body>

<fieldset class="venwin" style="height:auto;">
  <center>
    <span style="color:#990000;font-size:x-large;">–ö–∞–º—ñ–Ω—å –ª—é–±–æ–≤—ñ</span><br><br>
    <canvas id="canvas" width="900" height="600" style="border:1px solid #ccc;"></canvas>

    <div id="controls">
      <label>–§–æ–Ω: <input type="file" id="bgLoader" accept="image/*"></label>
      <label>–§–æ—Ç–æ –∑–∞–∫–æ—Ö–∞–Ω–∏—Ö: <input type="file" id="loveLoader" accept="image/*"></label>
      <input type="range" id="scaleSlider" min="0.1" max="3" step="0.01" value="1">
      <button id="undoBtn">‚ü≤ Undo</button>
      <button id="previewBtn">üëÅ –ü–µ—Ä–µ–≥–ª—è–¥</button>
      <button id="downloadBtn" style="display:none;">üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏</button>
    </div>
  </center>
</fieldset>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const bgLoader = document.getElementById('bgLoader');
const loveLoader = document.getElementById('loveLoader');
const scaleSlider = document.getElementById('scaleSlider');
const undoBtn = document.getElementById('undoBtn');
const previewBtn = document.getElementById('previewBtn');
const downloadBtn = document.getElementById('downloadBtn');

// —à–∞–±–ª–æ–Ω (–ø–æ–≤–µ—Ä—Ö)
const template = new Image();
template.src = 'images/LoveStone.png';

// –º–æ–¥–µ–ª—ñ —à–∞—Ä—ñ–≤
let layers = {
  bg: { img: null, src: null, x: canvas.width/2, y: canvas.height/2, scale: 1 },
  love: { img: null, src: null, x: canvas.width/2, y: canvas.height/2, scale: 1 }
};

let activeLayer = null;
let previewMode = false;

// —ñ—Å—Ç–æ—Ä—ñ—è
const history = [];
const MAX_HISTORY = 20;

function makeSnapshot(){
  return {
    bg: { src: layers.bg.src, x: layers.bg.x, y: layers.bg.y, scale: layers.bg.scale },
    love: { src: layers.love.src, x: layers.love.x, y: layers.love.y, scale: layers.love.scale },
    previewMode: previewMode,
    activeLayer: activeLayer
  };
}

function pushHistory(){
  history.push(makeSnapshot());
  if(history.length > MAX_HISTORY) history.shift();
}

function applySnapshot(snapshot){
  previewMode = !!snapshot.previewMode;
  activeLayer = snapshot.activeLayer || null;
  const jobs = [];

  ['bg','love'].forEach(key => {
    const s = snapshot[key];
    if(s && s.src){
      const img = new Image();
      const p = new Promise(res => {
        img.onload = () => {
          layers[key].img = img;
          layers[key].src = s.src;
          layers[key].x = s.x;
          layers[key].y = s.y;
          layers[key].scale = s.scale;
          res();
        };
        img.onerror = () => { layers[key].img = null; layers[key].src = null; res(); };
      });
      img.src = s.src;
      jobs.push(p);
    } else {
      layers[key].img = null;
      layers[key].src = null;
      layers[key].x = s ? s.x : canvas.width/2;
      layers[key].y = s ? s.y : canvas.height/2;
      layers[key].scale = s ? s.scale : 1;
    }
  });

  toggleButtons();
  if(jobs.length) return Promise.all(jobs).then(drawAll);
  drawAll();
  return Promise.resolve();
}

// –í—ñ–¥–º–∞–ª—é–≤–∞–Ω–Ω—è —à–∞—Ä—É
function drawLayerTo(ctxTarget, layer){
  if(!layer || !layer.img) return;
  const w = layer.img.width * layer.scale;
  const h = layer.img.height * layer.scale;
  ctxTarget.drawImage(layer.img, layer.x - w/2, layer.y - h/2, w, h);
}

// –º–∞–ª—é—î–º–æ –≤—Å—ñ —à–∞—Ä–∏
function drawAll(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if(previewMode){
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width; tmp.height = canvas.height;
    const tctx = tmp.getContext('2d');

    // –º–∞–ª—é—î–º–æ —Ñ–æ–Ω
    if(layers.bg.img){
      tctx.save();
      const r = Math.min(canvas.width, canvas.height) / 2;
      tctx.beginPath();
      tctx.arc(layers.bg.x, layers.bg.y, r, 0, Math.PI*2);
      tctx.clip();
      const w = layers.bg.img.width * layers.bg.scale;
      const h = layers.bg.img.height * layers.bg.scale;
      tctx.drawImage(layers.bg.img, layers.bg.x - w/2, layers.bg.y - h/2, w, h);
      tctx.restore();
    }

    // –º–∞–ª—é—î–º–æ love
    if(layers.love.img){
      tctx.save();
      const r = Math.min(canvas.width, canvas.height) / 2;
      tctx.beginPath();
      tctx.arc(layers.love.x, layers.love.y, r, 0, Math.PI*2);
      tctx.clip();
      const w = layers.love.img.width * layers.love.scale;
      const h = layers.love.img.height * layers.love.scale;
      tctx.drawImage(layers.love.img, layers.love.x - w/2, layers.love.y - h/2, w, h);
      tctx.restore();
    }

    // –ø–µ—Ä–µ–Ω–æ—Å–∏–º–æ –Ω–∞ –æ—Å–Ω–æ–≤–Ω–∏–π canvas
    ctx.drawImage(tmp, 0, 0);
    if(template.complete) ctx.drawImage(template, 0, 0, canvas.width, canvas.height);

  } else {
    drawLayerTo(ctx, layers.bg);
    drawLayerTo(ctx, layers.love);
    if(template.complete) ctx.drawImage(template, 0, 0, canvas.width, canvas.height);
  }
}

// –ö–Ω–æ–ø–∫–∏ —Ç–∞ —Å–ª–∞–π–¥–µ—Ä
function toggleButtons(){
  previewBtn.style.display = previewMode ? 'none' : 'inline-block';
  downloadBtn.style.display = previewMode ? 'inline-block' : 'none';
}

function handleFileLoad(file, key){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    const img = new Image();
    img.onload = () => {
      layers[key].img = img;
      layers[key].src = e.target.result;
      layers[key].x = canvas.width/2;
      layers[key].y = canvas.height/2;
      layers[key].scale = 1;
      activeLayer = key;
      scaleSlider.value = 1;
      pushHistory();
      drawAll();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

bgLoader.addEventListener('change', e => handleFileLoad(e.target.files[0], 'bg'));
loveLoader.addEventListener('change', e => handleFileLoad(e.target.files[0], 'love'));

scaleSlider.addEventListener('input', () => {
  if(!activeLayer) return;
  layers[activeLayer].scale = parseFloat(scaleSlider.value);
  drawAll();
});
scaleSlider.addEventListener('change', () => { if(!activeLayer) return; pushHistory(); });

// Drag & Touch
let dragging = false, dragStartX = 0, dragStartY = 0;
canvas.addEventListener('mousedown', e => {
  if(!activeLayer) return;
  dragging = true;
  dragStartX = e.offsetX - layers[activeLayer].x;
  dragStartY = e.offsetY - layers[activeLayer].y;
});
canvas.addEventListener('mousemove', e => {
  if(!dragging || !activeLayer) return;
  layers[activeLayer].x = e.offsetX - dragStartX;
  layers[activeLayer].y = e.offsetY - dragStartY;
  drawAll();
});
canvas.addEventListener('mouseup', () => { if(dragging){ dragging=false; pushHistory(); } });
canvas.addEventListener('mouseleave', () => { if(dragging){ dragging=false; pushHistory(); } });
canvas.addEventListener('touchstart', e => {
  if(!activeLayer) return;
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  dragging = true;
  dragStartX = t.clientX - rect.left - layers[activeLayer].x;
  dragStartY = t.clientY - rect.top - layers[activeLayer].y;
  e.preventDefault();
});
canvas.addEventListener('touchmove', e => {
  if(!dragging || !activeLayer) return;
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  layers[activeLayer].x = t.clientX - rect.left - dragStartX;
  layers[activeLayer].y = t.clientY - rect.top - dragStartY;
  drawAll(); e.preventDefault();
});
canvas.addEventListener('touchend', () => { if(dragging){ dragging=false; pushHistory(); } });

// Undo
undoBtn.addEventListener('click', () => {
  if(history.length <= 1) return;
  history.pop();
  applySnapshot(history[history.length-1]);
});

// Preview
previewBtn.addEventListener('click', () => {
  previewMode = true;
  pushHistory();
  toggleButtons();
  drawAll();
});

// Download
downloadBtn.addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'composition.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

template.onload = () => { drawAll(); };
pushHistory();
applySnapshot(history[0]);
</script>
</body>
</html>
