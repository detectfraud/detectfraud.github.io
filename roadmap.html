<!-- Collage (12) 21:20 26.08.25 -->
<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>–ö–∞–º—ñ–Ω—å –ª—é–±–æ–≤—ñ ‚Äî —Ä–µ–¥–∞–∫—Ç–æ—Ä</title>
  <style>
    body { text-align:center; font-family:sans-serif; background:#f5f5f5; }
    .venwin { background:#fff; border-radius:10px; padding:10px; display:inline-block; }
    canvas { border:3px solid #bbb; border-radius:6px; box-shadow:0 6px 18px rgba(0,0,0,.1); display:block; margin:10px auto; }
    #scaleSlider { width:420px; }
    button { padding:8px 12px; }
    .disabled { pointer-events:none; opacity:.5; filter:grayscale(100%); }
  </style>
</head>
<body>
<fieldset class="venwin" style="height:auto;">
  <canvas id="canvas" width="900" height="600"></canvas>
  <br>
  <input type="range" id="scaleSlider" min="0.1" max="3" step="0.01" value="1"><br><br>
  <label>–§–æ–Ω: <input type="file" id="bgLoader" accept="image/*"></label><br><br>
  <label>–§–æ—Ç–æ: <input type="file" id="loveLoader" accept="image/*"></label><br><br>
  <button id="undoBtn">‚ü≤ Undo</button>
  <button id="previewBtn">üëÅ –ü–µ—Ä–µ–≥–ª—è–¥</button>
  <button id="downloadBtn" style="display:none;">üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏</button>
</fieldset>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const bgLoader = document.getElementById('bgLoader');
const loveLoader = document.getElementById('loveLoader');
const scaleSlider = document.getElementById('scaleSlider');
const undoBtn = document.getElementById('undoBtn');
const previewBtn = document.getElementById('previewBtn');
const downloadBtn = document.getElementById('downloadBtn');

// –®–∞–±–ª–æ–Ω
const template = new Image();
template.src = 'images/composit.png';

// –ú–∞—Å–∫–∞ –¥—ñ—Ä–∫–∏
const HOLE_OFFSET_X = 6;
const HOLE_OFFSET_Y = -115;
const HOLE_RADIUS = 98;
let mask = { cx:0, cy:0, r:0 };
function setDefaultMask(){
  mask.cx = canvas.width/2 + HOLE_OFFSET_X;
  mask.cy = canvas.height/2 + HOLE_OFFSET_Y;
  mask.r = HOLE_RADIUS;
}

// –®–∞—Ä–∏
let layers = {
  bg: { img:null, src:null, x:canvas.width/2, y:canvas.height/2, scale:1 },
  love: { img:null, src:null, x:canvas.width/2, y:canvas.height/2, scale:1 }
};
let activeLayer = null;
let previewMode = false;
let bgHoleActive = true; // **–¥—ñ—Ä–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –ø—ñ–¥ —á–∞—Å —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è**

const history = [];
const MAX_HISTORY = 20;

function makeSnapshot(){
  return {
    bg:{...layers.bg}, love:{...layers.love},
    previewMode, activeLayer, bgHoleActive
  };
}
function pushHistory(){
  history.push(makeSnapshot());
  if(history.length>MAX_HISTORY) history.shift();
}
function applySnapshot(s){
  previewMode = !!s.previewMode;
  activeLayer = s.activeLayer || null;
  bgHoleActive = !!s.bgHoleActive;
  const jobs = [];
  ['bg','love'].forEach(k=>{
    const v=s[k];
    if(v && v.src){
      const img=new Image();
      const p=new Promise(res=>{
        img.onload = ()=>{
          layers[k].img=img;
          layers[k].src=v.src;
          layers[k].x=v.x; layers[k].y=v.y; layers[k].scale=v.scale;
          res();
        };
        img.onerror = ()=>{ layers[k].img=null; layers[k].src=null; res(); };
      });
      img.src=v.src;
      jobs.push(p);
    } else {
      layers[k].img=null; layers[k].src=null;
      layers[k].x=v?v.x:canvas.width/2;
      layers[k].y=v?v.y:canvas.height/2;
      layers[k].scale=v?v.scale:1;
    }
  });
  toggleButtons();
  if(jobs.length) return Promise.all(jobs).then(drawAll);
  drawAll();
  return Promise.resolve();
}
pushHistory();

// –ú–∞–ª—é–≤–∞–Ω–Ω—è
function drawLayerTo(ctxT, layer){
  if(!layer || !layer.img) return;
  const w=layer.img.width*layer.scale;
  const h=layer.img.height*layer.scale;
  ctxT.drawImage(layer.img, layer.x-w/2, layer.y-h/2, w, h);
}
function drawLove(ctxT, clip=false){
  const L=layers.love; if(!L||!L.img) return;
  const w=L.img.width*L.scale, h=L.img.height*L.scale;
  ctxT.save();
  if(clip && mask.r>0){
    ctxT.beginPath();
    ctxT.arc(mask.cx, mask.cy, mask.r,0,Math.PI*2);
    ctxT.clip();
  }
  ctxT.drawImage(L.img, L.x-w/2, L.y-h/2, w, h);
  ctxT.restore();
}
function drawBgWithHole(ctxT){
  if(!layers.bg.img) return;
  if(!bgHoleActive || mask.r<=0){
    drawLayerTo(ctxT,layers.bg);
    return;
  }
  const off=document.createElement('canvas');
  off.width=canvas.width; off.height=canvas.height;
  const octx=off.getContext('2d');
  drawLayerTo(octx,layers.bg);
  octx.globalCompositeOperation='destination-out';
  octx.beginPath();
  octx.arc(mask.cx, mask.cy, mask.r,0,Math.PI*2);
  octx.fill();
  octx.globalCompositeOperation='source-over';
  ctxT.drawImage(off,0,0);
}
function drawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBgWithHole(ctx);  // **–¥—ñ—Ä–∫–∞ –ø—ñ–¥ —á–∞—Å —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è**
  drawLove(ctx,false);
  if(template.complete) ctx.drawImage(template,0,0,canvas.width,canvas.height);
}

function toggleButtons(){
  if(previewMode){
    previewBtn.style.display='none';
    downloadBtn.style.display='inline-block';
    setDisabled(true);
  } else {
    previewBtn.style.display='inline-block';
    downloadBtn.style.display='none';
    setDisabled(false);
  }
}

// –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤
function handleFileLoad(file,key){
  if(!file) return;
  const reader=new FileReader();
  reader.onload=e=>{
    const data=e.target.result;
    const img=new Image();
    img.onload = ()=>{
      layers[key].img=img; layers[key].src=data;
      layers[key].x=canvas.width/2; layers[key].y=canvas.height/2; layers[key].scale=1;
      activeLayer=key; scaleSlider.value=1;
      pushHistory(); drawAll();
    };
    img.src=data;
  };
  reader.readAsDataURL(file);
}
bgLoader.addEventListener('change',e=>handleFileLoad(e.target.files[0],'bg'));
loveLoader.addEventListener('change',e=>handleFileLoad(e.target.files[0],'love'));

// –ú–∞—Å—à—Ç–∞–±
scaleSlider.addEventListener('input',()=>{
  if(!activeLayer) return;
  layers[activeLayer].scale=parseFloat(scaleSlider.value);
  drawAll();
});

// –ü–µ—Ä–µ—Ç—è–≥—É–≤–∞–Ω–Ω—è
let dragging=false, dragStartX=0, dragStartY=0;
canvas.addEventListener('mousedown',e=>{
  if(previewMode||!activeLayer) return;
  dragging=true;
  dragStartX=e.offsetX-layers[activeLayer].x;
  dragStartY=e.offsetY-layers[activeLayer].y;
});
canvas.addEventListener('mousemove',e=>{
  if(previewMode||!dragging||!activeLayer) return;
  layers[activeLayer].x=e.offsetX-dragStartX;
  layers[activeLayer].y=e.offsetY-dragStartY;
  drawAll();
});
function stopDrag(){ if(dragging){ dragging=false; pushHistory(); } }
canvas.addEventListener('mouseup',stopDrag);
canvas.addEventListener('mouseleave',stopDrag);

// Touch
canvas.addEventListener('touchstart',e=>{
  if(previewMode||!activeLayer) return;
  const t=e.touches[0], rect=canvas.getBoundingClientRect();
  dragging=true;
  dragStartX=t.clientX-rect.left-layers[activeLayer].x;
  dragStartY=t.clientY-rect.top-layers[activeLayer].y;
  e.preventDefault();
});
canvas.addEventListener('touchmove',e=>{
  if(previewMode||!dragging||!activeLayer) return;
  const t=e.touches[0], rect=canvas.getBoundingClientRect();
  layers[activeLayer].x=t.clientX-rect.left-dragStartX;
  layers[activeLayer].y=t.clientY-rect.top-dragStartY;
  drawAll(); e.preventDefault();
});
canvas.addEventListener('touchend',stopDrag);

// UNDO
undoBtn.addEventListener('click',()=>{
  if(history.length<=1) return;
  history.pop();
  applySnapshot(history[history.length-1]);
});

// PREVIEW
previewBtn.addEventListener('click',()=>{
  previewMode=true;
  pushHistory();
  toggleButtons();
  drawAll();
});

// DOWNLOAD
downloadBtn.addEventListener('click',()=>{
  const link=document.createElement('a');
  link.download='composition.png';
  link.href=canvas.toDataURL('image/png');
  link.click();
});

// –®–∞–±–ª–æ–Ω
template.onload=()=>{
  setDefaultMask();
  drawAll();
};

// –ö–æ–Ω—Ç—Ä–æ–ª—ñ
function setDisabled(state){
  [bgLoader,loveLoader,scaleSlider].forEach(el=>{
    el.disabled=!!state;
    el.classList.toggle('disabled',!!state);
  });
}
</script>
</body>
</html>
